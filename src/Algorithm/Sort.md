## Sort
> 面试当中最常问到的八大排序

 ### 八大排序
 不稳定：
 - [选择排序](#选择排序)
 - [希尔排序](#希尔排序)
 - [快速排序](#快速排序)
 - [堆排序](#堆排序)

 稳定：
 - [冒泡排序](#冒泡排序)
 - [归并排序](#归并排序)
 - [插入排序](#插入排序)
 - [基数排序](#基数排序)

 ### 稳定性的意义
 目的：`保证两次排序的结果相同`
  - 比如先按ID（从小到大排序），已经排好了；
  - 再按体重排序（轻的在前面、重的在后面），遇到体重相等时，就按ID排
  - 如果是稳定性的算法，结果是相同的（体重相同者，ID小的在前面）
  - 如果是不稳定的算法，结果可能是（体重相同者，ID小的在后面）
 
 ### 冒泡排序
 时间复杂度：O(n²)

 思想：重复遍历待排序列，依次比较两个元素。如果顺序错误就交换。

```js
function bubbleSort(arr) {
  for (let i = 0; i < arr.length; i++) { // i代表轮次
    // -1代表要保证后面有数和他比较，-i表示最后已排好了 i 个
    for (let j = 0; j < arr.length - 1 - i; j++) {
      if (arr[j] > arr[j+1]) {
        [arr[j], arr[j+1]] = [arr[j+1], arr[j]]
      }
    }
  }
  return arr
}

```
 
 例子：[1, 9, 7, 6]
  - 一共比较`3`轮，当前`第1轮`
  - 通过两两比较，把符合条件的交换位置
    - 1和9比，不换；
    - 9和7比，换。【此时1, 7, 9, 6】
    - 9和6比，换。【此时1, 7, 6, 9】
  - 第`1`轮结束，第`1`大的数（9）推到了最后

 ### 归并排序
 时间复杂度：O(nlog2n)

 思想：利用`分治策略`，把待排序列递归划分为多个子序列，再将子序列的各项进行比较、合并，从而得到有序子序列。以此类推，直至得到最终有序序列。

 ```js
 function mergeSort(arr) {
   if (arr.length < 2) return arr

   let middle = Math.floor(arr.length / 2),
       left = arr.slice(0, middle),
       right = arr.slice(middle)

    return merge(mergeSort(left), mergeSort(right))
 }

 function merge(left, right) {
   let result = []

   while(left.length > 0 && right.length > 0) {
     result.push(left[0] <= right[0] ? left.shift() : right.shift())
   }

   return result.concat(left).concat(right) // left、right长度不等，连接即可
 }
 ```

 例子：[1, 9, 7, 6]
  - 把数组[1, 9, 7, 6]划分为[1, 9]、[7, 6]
  - 对于[1, 9]会划分为[1]、[9]
  - 对于[1]、[9]不能再往下划分，该分支开始合并
  - 【合并】对于[1]、[9]两个子数组进行合并（result=[]）
  - 【合并】1和9比，1小，所以1从[1]里shift出去（result=[1]），剩下[9]、[]
  - 【合并】由于第二个子数组长度为0，直接concat。（result.concat(left）.concat(right)，即[1, 9]）
  - 【合并】同理，[7]、[6]合并为[6, 7]
  - 【合并】对于[1, 9]和[6, 7]两个子数组进行合并（result=[]）
  - 【合并】1和6比，1小，所以1从[1, 9]里shift出去（result=[1]），剩下[9]、[6, 7]
  - 【合并】9和6比，6小，所以6从[6, 7]里shift出去（result=[1, 6]），剩下[9]、[7]
  - 【合并】9和7比，7小，所以7从[7]里shift出去（result=[1, 6, 7]），剩下[9]、[]
  - 【合并】由于第二个子数组长度为0，直接concat。（result.concat(left）.concat(right)，即[1, 6, 7, 9）
  - 最终数组[1, 6, 7, 9]

 ### 插入排序
 时间复杂度：O(n²)

 思路：依次将`无序序列`中的一个记录，按它的大小在`已排序列`中**从后向前扫描**，插入到相应位置。直到所有的记录都插入为止。

 ```js
 function insertionSort(arr) {
   let preIndex, curValue

   for (let i = 1; i < arr.length; i++) {
     preIndex = i - 1
     curValue = arr[i]
     while (preIndex >=0 && arr[preIndex] > curValue) {
       arr[preIndex + 1] = arr[preIndex]
       preIndex--
     }
     arr[preIndex + 1] = curValue
   }

   return arr
 }
 ```

 大致思想：
  - 一共比较`length - 1`轮，从下标为`1`开始
  - 将数组分为`有序组`、`无序组`（以index=1为“分界线”）
  - 每轮取`无序组`的第一位，赋值temp，开始进行排序
  - 取`有序组`中最后一位的下标，赋值j，记录其下标
  - 将j开始一直递减，为temp找到合适的位置，并将其插入

 例子：[1, 9, 7, 6]
  - 一共进行`3`轮，当前`第1轮`
  - 有序组是[1]，无序组是[9, 7, 6]（不是真实数组）
  - 取无序组的第一位(9)，赋值temp（9），开始进行排序，此时数组[1, 9, 7, 6]，temp=9
  - 取`有序组`的最后一位（1）的下标，赋值j，（j=0）
  - 取`有序组`的最后一位（1），它没有比temp（9）大，不换，此时数组[1, 9, 7, 6]，temp=9，j=0
  - 因为到达`有序组`顶端（j=0），将temp（9）放到`有序组（j+1）位`，此时数组[1, 9, 7, 6]，进行`第2轮`
  - 有序组是[1, 9]，无序组是[7, 6]（不是真实数组）
  - 取无序组的第一位(7)，赋值temp（7），开始进行排序，此时数组[1, 9, 7, 6]，temp=7
  - 取`有序组`的最后一位（9）的下标，赋值j，（j=1）
  - `有序组`最后一位（9）比temp（7）大，将`有序组`该位置的数覆盖到下一位，此时数组[1, 9, 9, 6]，temp=7，j=1
  - 再往前看是否有更适合的地方，j--，（j=0）
  - `有序组`第0位（1），它没有比temp（7）大，不换，此时数组[1, 9, 9, 6]，temp=7，j=0
  - 因为到达`有序组`顶端（j=0），将temp（7）放到`有序组（j+1）位`，此时数组[1, 7, 9, 6]，进行`第3轮`
  - 有序组是[1, 7, 9]，无序组是[6]（不是真实数组）
  - 取无序组的第一位(6)，赋值temp（6），开始进行排序，此时数组[1, 7, 9, 6]，temp=6
  - 取`有序组`的最后一位（9）的下标，赋值j，（j=2）
  - `有序组`最后一位（9）比temp（6）大，将`有序组`该位置的数覆盖到下一位，此时数组[1, 7, 9, 9]，temp=6，j=2
  - 再往前看是否有更适合的地方，j--，（j=1）
  - `有序组`第1位（7）比temp（6）大，将`有序组`该位置的数覆盖到下一位，此时数组[1, 7, 7, 9]，temp=6，j=1
  - 再往前看是否有更适合的地方，j--，（j=0）
  - `有序组`第0位（1），它没有比temp（6）大，不换，此时数组[1, 7, 7, 9]，temp=6，j=0
  - 因为到达`有序组`顶端（j=0），将temp（6）放到`有序组（j+1）位`，此时数组[1, 6, 7, 9]，结束排序。
  


 
 ### 选择排序
 时间复杂度：O(n²)
 
 思想：在待排序列中找到最小元素，存放到已排序序列的起始位置；然后再从剩余未排序元素中，继续寻找最小元素，放到已排序列的末尾。

 ```js
 function selectionSort(arr) {
   var minIndex
   for (let i = 0; i < arr.length; i++) {
     minIndex = i
     for (let j = i + 1; j < arr.length; j++) {
       if (arr[j] < arr[minIndex]) {
         minIndex = j // 在循环后面数的时候发现比我初始定的min还小
       }
     }
     [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]]
   }
   return arr
 }
 ```

 大致思想：
  - 一共比较`length - 1`轮，当前`第i轮`（i代表的是第i个位置应该放什么数）
  - 每轮会把`第i个`位置的数拷贝到min
  - 将`第i个`位置后面的每个数都和这个min比较
  - 如果比较后符合条件，交换位置（即把更小的数放到min，把min里的数放到这个数的位置）
  - 该轮结束后，把min里的数赋值到`第i个位置上`
 
 例子：[1, 9, 7, 6]
  - 一共进行`3`轮，当前`第1轮`
  - 把`第一个`位置的数（1）拷贝到min
  - 将`9`和`1`比较，不换
  - 将`7`和`1`比较，不换
  - 将`6`和`1`比较，不换，本轮结束，将min赋值到`第一个`位置上，数组为[1, 9, 7, 6]
  - 把`第二个`位置的数（9）拷贝到min
  - 将`7`和`9`比较，换。此时min=7，数组为[1, 9, 9, 6]
  - 将`6`和`7`比较，换。此时min=6，数组为[1, 9, 9, 7]，本轮结束，将min赋值到`第二个`位置上，数组为[1, 6, 9, 7]
  - 把`第三个`位置的数（9）拷贝到min
  - 将`7`和`9`比较，换。此时min=7，数组为[1, 6, 9, 9]，本轮结束，将min赋值到`第三个`位置上，数组为[1, 6, 7, 9]
  - 最终数组[1, 6, 7, 9]

 ### 希尔排序
 时间复杂度：O(nlog2n) ~ O(n²)

 思想：是简单插入排序的改进版。会优先比较距离较远的元素，又叫缩小增量排序

 ```js
 function shellSort(arr) {
    let temp,
       gap = 1
    while (gap < arr.length / 3) {
      gap = gap * 3 + 1
    }
    for(gap; gap > 0; gap = Math.floor(gap / 3)) {
      for (let i = gap; i < arr.length; i++) {
        temp = arr[i]
        // 注意，对于j是var
        for(var j = i - gap; j > 0 && arr[j] > temp; j -= gap) {
          arr[j + gap] = arr[j]
        }
        arr[j + gap] = temp
      }
    }
    return arr
 }
 ```


 ### 快速排序
 时间复杂度：O(nlog2n)

 思想：
  - 选择一个元素作为“基准”（pivot），记录其值、下标
  - 所有小于“基准”的元素，移到“基准”的左边；所有大于“基准”的元素，都移到“基准”的右边
  - 对“基准”左、右两个子集，不断重复第一、二步，直到所有子集`只剩下一个元素`为止
 
 代码：
 ```js
const quickSort = arr => arr.length <= 1 ? arr :
      quickSort(arr.filter(x => x < arr[0]))
      .concat(arr.filter(x => x == arr[0]))
      .concat(quickSort(arr.filter(x => x > arr[0])))
 ```

 ### 基数排序
 时间复杂度：O(nlog(r)m)，其中r为所采取的基数，m为堆数

 思想：按照个位先排序，然后收集；再按照高位排序，然后再收集；以此类推，直到最高位。

 ### 堆排序
 时间复杂度：O(nlog2n)

 思想：把数组看成一个完全二叉树