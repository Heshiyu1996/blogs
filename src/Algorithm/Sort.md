## Sort
> 面试当中最常问到的八大排序

 ### 八大排序
 不稳定：
 - 简单选择排序
 - 希尔排序
 - 快速排序
 - 堆排序

 稳定：
 - 冒泡排序
 - 归并排序
 - 插入排序
 - 基数排序

 ### 稳定性的意义
 目的：`保证两次排序的结果相同`
  - 比如先按ID（从小到大排序），已经排好了；
  - 再按体重排序（轻的在前面、重的在后面），遇到体重相等时，就按ID排
  - 如果是稳定性的算法，结果是相同的（体重相同者，ID小的在前面）
  - 如果是不稳定的算法，结果可能是（体重相同者，ID小的在后面）
 
 ### 冒泡排序
 复杂度：O(n²)

 大致思想：
  - 一共比较`length - 1`轮，当前`第i轮`
  - 每轮会通过两两比较，把符合条件的交换位置
  - 第i轮结束时，会把第i大的数推到最后
 
 例子：[1, 9, 7, 6]
  - 一共比较`3`轮，当前`第1轮`
  - 通过两两比较，把符合条件的交换位置
    - 1和9比，不换；
    - 9和7比，换。【此时1, 7, 9, 6】
    - 9和6比，换。【此时1, 7, 6, 9】
  - 第`1`轮结束，第`1`大的数（9）推到了最后

 ### 归并排序
 复杂度：O(nlog2n)

 大致思想：
  - 利用分治策略（先划分，后合并）
  - 把大数组C划分为两个数组A、B（从C中间分开）
  - 对于数组A、B分别重复步骤1，进行递归划分（直到每个子数组只剩下1个元素）
  - 合并前，会将两个子数组中的元素进行排序，然后排序并组成一个新的数组返回给下一轮的合并
  - 需保证即将合并的两个子数组内，是排好序的

 例子：[1, 9, 7, 6]
  - 把数组[1, 9, 7, 6]划分为[1, 9]、[7, 6]
  - 对于[1, 9]会划分为[1]、[9]
  - 对于[1]、[9]不能再往下划分，该分支开始合并
  - 【合并】对于[1]、[9]两个子数组进行合并（result=[]）
  - 【合并】1和9比，1小，所以1从[1]里shift出去（result=[1]），剩下[9]、[]
  - 【合并】由于第二个子数组长度为0，直接concat。（result.concat(left）.concat(right)，即[1, 9]）
  - 【合并】同理，[7]、[6]合并为[6, 7]
  - 【合并】对于[1, 9]和[6, 7]两个子数组进行合并（result=[]）
  - 【合并】1和6比，1小，所以1从[1, 9]里shift出去（result=[1]），剩下[9]、[6, 7]
  - 【合并】9和6比，6小，所以6从[6, 7]里shift出去（result=[1, 6]），剩下[9]、[7]
  - 【合并】9和7比，7小，所以7从[7]里shift出去（result=[1, 6, 7]），剩下[9]、[]
  - 【合并】由于第二个子数组长度为0，直接concat。（result.concat(left）.concat(right)，即[1, 6, 7, 9）
  - 最终数组[1, 6, 7, 9]

 ### 插入排序
 时间复杂度：O(n²)

 思路：依次将`无序序列`中的一个记录，按它的大小插入到一个`已排好序的子序列中的适当位置`，直到所有的记录都插入为止。

 大致思想：
  - 一共比较`length - 1`轮，从下标为`1`开始
  - 将数组分为`有序组`、`无序组`（以index=1为“分界线”）
  - 每轮取`无序组`的第一位，赋值temp，开始进行排序
  - 取`有序组`中最后一位的下标，赋值j，记录其下标
  - 将j开始一直递减，为temp找到合适的位置，并将其插入

 例子：[1, 9, 7, 6]
  - 一共进行`3`轮，当前`第1轮`
  - 有序组是[1]，无序组是[9, 7, 6]（不是真实数组）
  - 取无序组的第一位(9)，赋值temp（9），开始进行排序，此时数组[1, 9, 7, 6]，temp=9
  - 取`有序组`的最后一位（1）的下标，赋值j，（j=0）
  - 取`有序组`的最后一位（1），它没有比temp（9）大，不换，此时数组[1, 9, 7, 6]，temp=9，j=0
  - 因为到达`有序组`顶端（j=0），将temp（9）放到`有序组（j+1）位`，此时数组[1, 9, 7, 6]，进行`第2轮`
  - 有序组是[1, 9]，无序组是[7, 6]（不是真实数组）
  - 取无序组的第一位(7)，赋值temp（7），开始进行排序，此时数组[1, 9, 7, 6]，temp=7
  - 取`有序组`的最后一位（9）的下标，赋值j，（j=1）
  - `有序组`最后一位（9）比temp（7）大，将`有序组`该位置的数覆盖到下一位，此时数组[1, 9, 9, 6]，temp=7，j=1
  - 再往前看是否有更适合的地方，j--，（j=0）
  - `有序组`第0位（1），它没有比temp（7）大，不换，此时数组[1, 9, 9, 6]，temp=7，j=0
  - 因为到达`有序组`顶端（j=0），将temp（7）放到`有序组（j+1）位`，此时数组[1, 7, 9, 6]，进行`第3轮`
  - 有序组是[1, 7, 9]，无序组是[6]（不是真实数组）
  - 取无序组的第一位(6)，赋值temp（6），开始进行排序，此时数组[1, 7, 9, 6]，temp=6
  - 取`有序组`的最后一位（9）的下标，赋值j，（j=2）
  - `有序组`最后一位（9）比temp（6）大，将`有序组`该位置的数覆盖到下一位，此时数组[1, 7, 9, 9]，temp=6，j=2
  - 再往前看是否有更适合的地方，j--，（j=1）
  - `有序组`第1位（7）比temp（6）大，将`有序组`该位置的数覆盖到下一位，此时数组[1, 7, 7, 9]，temp=6，j=1
  - 再往前看是否有更适合的地方，j--，（j=0）
  - `有序组`第0位（1），它没有比temp（6）大，不换，此时数组[1, 7, 7, 9]，temp=6，j=0
  - 因为到达`有序组`顶端（j=0），将temp（6）放到`有序组（j+1）位`，此时数组[1, 6, 7, 9]，结束排序。
  


 
 ### 选择排序
 时间复杂度：O(n²)
 
 思想：利用“分治策略”不断把`待排序列`的`有序子序列`进行合并，直到合并为一个有序序列为止。

 大致思想：
  - 一共比较`length - 1`轮，当前`第i轮`（i代表的是第i个位置应该放什么数）
  - 每轮会把`第i个`位置的数拷贝到min
  - 将`第i个`位置后面的每个数都和这个min比较
  - 如果比较后符合条件，交换位置（即把更小的数放到min，把min里的数放到这个数的位置）
  - 该轮结束后，把min里的数赋值到`第i个位置上`
 
 例子：[1, 9, 7, 6]
  - 一共进行`3`轮，当前`第1轮`
  - 把`第一个`位置的数（1）拷贝到min
  - 将`9`和`1`比较，不换
  - 将`7`和`1`比较，不换
  - 将`6`和`1`比较，不换，本轮结束，将min赋值到`第一个`位置上，数组为[1, 9, 7, 6]
  - 把`第二个`位置的数（9）拷贝到min
  - 将`7`和`9`比较，换。此时min=7，数组为[1, 9, 9, 6]
  - 将`6`和`7`比较，换。此时min=6，数组为[1, 9, 9, 7]，本轮结束，将min赋值到`第二个`位置上，数组为[1, 6, 9, 7]
  - 把`第三个`位置的数（9）拷贝到min
  - 将`7`和`9`比较，换。此时min=7，数组为[1, 6, 9, 9]，本轮结束，将min赋值到`第三个`位置上，数组为[1, 6, 7, 9]
  - 最终数组[1, 6, 7, 9]
