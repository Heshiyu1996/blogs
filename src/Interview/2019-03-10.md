# 2019-03-10
## First
### 移动端touch事件和web端click的区别
在移动端，在手指点击一个元素，会经过：**touchstart -> touchmove -> touchend -> click**

`touchstart`，手指一触碰就能触发

`click`，则需要：
 - 手指触碰
 - 手指未在屏幕上移动
 - 手指在这个dom节点上离开屏幕
 - 触摸和离开的时间间隔短
 - 如果不想触发click，可以执行`ev.preventDefault()`

 #### 两端在事件对象上的区别
 对于`TouchEvent`（触摸事件对象），它会比`MouseEvent`（鼠标事件对象）多出一些属性值：
  - touches
    - 当前屏幕上，所有`Touch对象`的列表
  - targetTouches
    - 当前对象上，所有`Touch对象`的列表
  - changedTouches
    - 涉及当前事件的，所有`Touch对象`的列表
 
 同时，与`MouseEvent`中有关位置/目标的属性：`clientX`、`clientY`；`pageX`、`pageY`；`screenX`、`screenY`、`target`会放到`Touch对象`中。

 #### click延时的问题
 原因：移动端上，两次轻触是放大操作。在第一次轻触后，浏览器会等一段时间（`300ms`延迟左右）来判断是否为连续触碰，才会触发`click`事件

 解决方式：
  - 原生解决：
    - 利用`touchstart`、`touchend`记录`时间`、`手指位置`。若期间手指处于同一位置、且时间很短、且期间未触发`touchmove`事件，则可触发`click`
  - 利用Zepto.js中的`tap`事件（`singleTap`点击事件）解决
    - 缺点：会发生`点透事件`
 
 #### “点透事件”
 原理：因为`tap`是通过`touch`事件模拟的，故`tap`要冒泡到`document`才触发
 原因：
  - 有两层A、B（A盖在上面）
  - 在`touchstart`阶段就隐藏了A；当`click`被触发时，能够使下面的B“被点击”
  - **touchstart -> touchmove -> touchend -> click**
 
 解决办法：为元素绑定`touchend`事件，并在内部加上`e.preventDefault()`，从而阻止`click`事件的产生

 #### “滑动事件”
 通过`touchstart`、`touchend`来计算此次的滑动方向。
 ```js
 // 调用时：setListenForWipe(elem, gesture, type)
 setListenForWipe(elem, gesture, type) {
     if (type) {
         // 1、绑定touchstart、touchend
         // 2、记录startX、startY（从ev.touches[0].pageX中取值）
         // 3、记录endX、endY（从ev.changedTouches[0].pageX中取值）
         // 4、取完endX、endY后计算角度、方向
         // 5、将方向赋值给传入的gesture对象
     } else {
         // 解绑touchstart、touchend
     }
 }
 ```
 注意：对于`touchend`事件，`touches`和`targetTouches`只存储接触到屏幕上的点，要获取最后离开的触摸点，要用`changedTouches`

### then方法先？还是SetTimeout先？
事件循环（event loop）

SetTimeout是在“下一轮事件循环开始时执行”

promise是在“本轮事件循环结束时执行”

```js
    setTimeout(function() {
        console.log(1)
    }, 0)
    new Promise(function(resolve, reject) {
        console.log(2)
        for(var i = 0 i < 10 i++) {
            i == 9 && resolve()
        }
        console.log(3)
    }).then(function() {
        console.log(4)
    })
    console.log(5)
```

### Promise的all方法不能抛出单个异常，改成能实现能抛异常并能被捕获？

### 对于行内元素、块级元素的水平/垂直居中如何实现？
#### `行内元素`：
 - 水平居中：
```css
/* A1 */
.parent {
    text-align: center;
}
```
 - 垂直居中：
```css
/* B1 */
.parent {
    height: 100px;
    line-height: 100px;
}

/* B2 */
.parent {
    display: table-cell;
    vertical-align: middle;
}
```
 - 水平垂直居中：
 ```css
 /* 不兼容flexbox */
    /* `A1` 与 `B1/B2`混合搭配  */
 
 /* 兼容flexbox */
    .parent {
        display: flex;
        justify-content: center;
        align-items: center;
    }
 ```

#### 块级元素：
 - 水平居中：
 ```css
 /* C1 */
 .child {
     margin: 0 auto;
 }
 /* C2 */
 .child {
     position: relative;
     margin: auto;
     left: 0;
     right: 0;
 }
 /* C3 */
 .parent {
     display: flex;
     justify-content: center;
 }
 ```
 - 垂直居中：
 ```css
 /* D1 */
 .parent {
     display: table-cell;
     vertical-align: middle;
 }
 ```
 - 水平垂直居中：
 ```css
 /* 不兼容flexbox */
    /* `C1/C2/C3` 与 `D1`混合搭配  */
 
 /* 兼容flexbox */
    .parent {
        display: flex;
        justify-content: center;
        align-items: center;
    }
 ```

### 行内元素有哪些？为什么img不是？“行块级元素”的专业术语？
行内替换元素。height/width/padding/margin均可用。效果等于块元素。

## Second
### 重构的好处？

### Flexbox的兼容性
IE10 及以上

### 节流函数 && 防抖函数
#### 节流函数
```js
function throttle(fn, delay = 500) {
    let startTime = Date.now()
    return function() {
        let args = arguments
        let currentTime = Date.now()
        if (currentTime - startTime > delay) {
            fn.apply(this, args)
            startTime = currentTime
        }
    }
}

var func = function(x) {
    console.log(x)
}

var myFunc = throttle(func, -1) // 为了test，delay设为-1
myFunc('heshiyu') // 'hehsiyu'
```
#### 防抖函数

### 两个异步请求，若第二个比第一个先返回，对于第一个的结果如何cancel掉？
栈

### CSS面试题
一个页面中，有Header、Content、Footer三部分。其中，Footer高度固定，但Content内容的高度不定。当Content内容小于多于一屏，Footer紧跟在Content的实际位置下方；当Content内容多于一屏，Footer固定在浏览器下方

### 通讯录搜索（按姓名查询、或按首拼音）
将各个汉字各自存起

### 一个page页面，有搜索框，展示框，说明下他们的职责

### 把svg当做字体