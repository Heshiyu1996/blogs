## 事件循环（EventLoop）
> JavaScript最大的特点就是 单线程（即，同一时间只能做同一件事）
> 
> 更新时间：2019-01-25

我是导航条：
[JS单线程的原因](#JS单线程的原因) -> [任务队列（taskQueue）](#任务队列（taskQueue）) -> [异步执行的运行机制](#异步执行的运行机制) -> [setTimeout](#setTimeout)

### JS单线程的原因
JavaScript的单线程和他的用途有关。它的主要用途是 **和用户互动、以及操作DOM**，如果它不是单线程，会带来很多复杂的问题。

比如JavaScript同时有两个线程，一个线程在某个DOM节点添加内容、一个线程删除了这个节点，浏览器应该 **以哪个线程为准？**

 - 所以，JavaScript就是单线程，将来也不会改变。

> 为了利用多核CPU的计算能力，HTML5提出了Web Worker标准，允许 JavaScript“创建多个线程”，但是 **子线程完全受主线程控制**，且不得操作DOM。所以，这个新标准并 **没有改变JavaScript是单线程的本质**。

### 任务队列（taskQueue）
任务分成两种：“同步任务（synchronous）”、“异步任务（asynchronous）”
 - 同步任务
    - 在主线程上排队执行的任务。只有前一个任务执行完毕，才能执行后一个任务
 - 异步任务
    - 不会一开始就进入“主线程”、但会进入“任务队列（task queue）”的任务；
    - 只有“任务队列”通知主线程，该任务才会进入主线程执行

> 同步任务可以视为 **没有异步任务的异步执行**

### 异步执行的运行机制
1、所有同步任务都在 **主线程** 执行，形成一个 `执行栈`；

2、主线程之外，还存在一个“任务队列（task queue）”，用来存放 **事件**的；

3、当 异步任务 有了运行结果，就会在“任务队列”中放置一个事件；

4、当 `执行栈` 中的所有同步任务执行完毕，系统就会读取“任务队列” 里的事件，然后去执行对应的异步任务，进入执行栈；

5、主线程不断重复 1-4

所以，只要主线程空了，就会去读取“任务队列”，这就是JavaScript的运行机制

![alt](./img/eventloop-1.png)

### setTimeout
`setTimeout()`和`setInterval()`都是定时器的功能，运行机制完全一样。

`setTimeout()`的含义是，指定某个任务在主线程的`最早可得的空闲时间` 执行（即，在“任务队列”的尾部添加一个事件），因此要等到 **“同步任务”** 和 **“任务队列”** 现有的事件都处理完，才会得到执行

> `HTML5`规定了`setTimeout()`的最短间隔，不得低于`4`毫秒（若低于，就会自动增加）。
>
> `setTimeout()`只是将事件插入了“任务队列”，所以必须等到当前代码（`执行栈`）执行完，主线程才会去执行它指定的回调函数。（*如果当前代码耗时很长，有可能要等很久*）